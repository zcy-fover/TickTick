## Head First设计模式

### OO基础

> #### 抽象、封装、多态、继承

### 设计原则

> - #### 找出应用中可能需要变化之处，把他们独立出来，不要和那些不需要变化的代码混合在一起；
>
> - #### 针对接口编程而不是针对实现编程
>
> - #### 多用组合少用继承 
>
> - #### 开放关闭原则 
>
> - #### 最少知识原则：对象之间的交互要尽可能的少 

### 策略模式

> #### 定义了算法族，分别封装起来，让他们之间可以互相替换，在这种模式下可以让算法的变化独立于他们的使用者

### 观察者模式

> #### 定义了对象之间的一对多依赖，这样当一个对象状态改变状态时，他的所有继承者都会收到通知并自动更新
>
> #### 观察者模式让主题和观察者之间松耦合

### 装饰者模式

> - #### 装饰者和被装饰者拥有共同的超类型
>
> - #### 可以用一个或者多个装饰者对象包装对象
>
> - #### 装饰者和被装饰对象拥有相同的超类，所以在任何需要使用超类型的地方都可以使用装饰过的对象代替
>
> - #### 装饰者可以在被装饰者对象的行为之前或之后加上自己的行为
>
> - #### 对象可以在任何时候被装饰

> - #### 装饰者模式的装饰者的行为来自自己和组件组合，继承超类型知识为了保证 装饰者和被装饰这达到类型匹配

> - #### 装饰者模式动态得将责任附加到对象上，

## 工厂模式

> - #### 工厂模式通过让子类决定该创建什么对象来达到将创建对象的过程封装

> #### 依赖倒置
>
> > - 变量不可以持有具体类的引用
> > - 不要让类派生自具体类
> > - 不要覆盖基类中已经实现的方法

### 单例模式

> #### 确保一个类只有一个实例，并且可以提供全局访问点（类访问）

###  命令模式

> #### 命令模式将请求封装成一个对象，以便不同的请求、队列或日志来参数化其他对象。命令模式也支持撤销操作。

### 适配器模式

> #### 将一个类的接口转换成客户期望的另一个接口，适配器让原本不兼容的接口可以合作

> - 对象适配器：通过组合实现
> - 类适配器：通过多继承实现

### 外观模式

> #### 外观模式提供了一个统一的接口，用来访问系统中的一群接口。外观模式定义了一个高层接口，让子系统的功能调用更简单；

> #### 外观不只是简化了接口，也将客户从子系统的接口中解耦

> #### 外观和适配器可以包装很多类，但是外观模式知识简化了接口的使用，适配器模式是将接口转换成不同的接口；

### 模板方法模式

> #### 模板方法定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现

> #### 模板方法可以使得子类在不改变算法结构的情况下，重新定义算法中的某些步骤

### 迭代器模式

> #### 提供一种方法顺序访问一个聚合对象的内部元素，而不暴露其内部的实现

### 组合模式

> #### 允许你将对象组合成树形结构来表现“ 整体 / 部分”层次结构，组合能让用户以一致的方式处理个别对象以及对象组合。

### 状态模式

> #### 状态模式允许对象在内部状态改变时改变他的行为，对象看起来好想改变了他的类。

<div style="text-align:center;margin-top:50px;margin-bottom:50px;">
    <img src="https://note.youdao.com/yws/api/personal/file/C2C6FCFDC10942B6A3532E6F0928E455?method=download&shareKey=c554dacfc5193c29d4b35682aa1226d9" />
</div>
