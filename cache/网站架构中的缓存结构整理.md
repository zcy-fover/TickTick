## 网站架构中的缓存
 ![image](https://note.youdao.com/yws/api/personal/file/F0430B67472F4B11B8577A56CC026CA4?method=download&shareKey=8d33adf1c1a85fbb1ed7c5d80c67f852)

  #### 客户端缓存
  > - 页面缓存
  > >  > 将之前渲染的页面保存为文件，当用户再次访问时可以避开网络连接，从而减少负载，提升性能和用户体验。
  > >  - 浏览器缓存
  > >
  > >  > HTTP1.0：与服务器约定规则进行，在服务器侧设置 Expires 的 HTTP 头来告诉客户端在重新请求文件之前多久是安全的，可以使用 if-midified-since 的条件请求来清空缓存，比较文件最初的下载时间和最后的更新时间，如果文件没有改变可以用 304-Not Modified 应答客户端
  > >  >
  > >  > HTTP1.1：缓存系统被形式化引入了 e-Tag 标签，e-Tag 标签是文件或者对象的唯一标识，当询问服务器某一个资源的 e-Tag 标签是否有效，有效会生成 304-Not Modified；否则返回 200 提供正确的文件
  > >  >
  > >  > ![e-Tag流程图](https://note.youdao.com/yws/api/personal/file/WEBb567791a999bb7f27b16a79d0c258432?method=download&shareKey=d9fe97b682b4e9bcef1909cd8093a87f)
  > >  >
  > >  > Cache-Control/Expires 和 Last-Modified/ETag 一期使用时，Cache-Control/Expires 的优先级要高于后者。即当本地缓存根据 Cache-Control/Expires 判断还在有效期内时，就不会在去服务器询问修改时间和实体标识了。
  > >  >
  > >  > 在html页面可以添加（并不是所有浏览器都支持）
  > >  >
  > >  > ```html
  > >  > <META HTTP-EQUIV="Pragma" CONTENT="no-cache">
  > >  > ```
  > >
  > >  - APP上缓存
  > >
  > >  > 数据库缓存：把文件的相关信息（URL、路径、下载时间、过期时间）等放到数据库中，下次查询先从数据库中查询做对比
  > >  >
  > >  > 文件缓存：使用文件操作的 API 获取文件的最后修改时间。图片和其他配置类文件的缓存时间不一样。图片的缓存时间可能可以持续到下次清空缓存，但是配置文件可能会被更新；在不同网络环境下缓存的更新时间也可以不一样

#### 网络中缓存

  > > - WEB 代理缓存
  > >
  > > > 正向代理
  > > >
  > > > 反向代理：客户端向代理服务发送请求，反向代理自己判断向何处发送请求，然后将从源服务获取到的内容返回给客户端
  > > >
  > > > 透明代理：客户端根本不需要知道有代理服务器的存在，又代理服务器改变客户端的请求报文，并传送真实的 IP 地址
  > > >
  > > > 匿名代理：加密的透明代理
  > >
  > > - 边缘缓存
  > >
  > > > 反向代理服务和用户来源于同一个网络，用户访问反向代理服务就会得到较高质量的响应，这种反向代理缓存叫做边缘缓存
  > > >
  > > > 边缘缓存的商业化服务- CDN
  > > >
  > > > CDN 缓存也是通过 HTTP 响应头的 Cache-Control:max-age 字段来设置 CDN 边缘节点的数据缓存时间，当客户端向 CDN 节点请求数据时，CDN 回先判断缓存时间是否过期，没有过期则将缓存返回给客户端，过期则像服务器请求数据并更新本地缓存。

#### 服务端缓存

  > > - 数据库缓存
  > >
  > > > query cache：作用于 MySQL 实例，主要针对于 select 语句，MySQL 将接收到的 select 语句以字符串进行 hash，然后在 query cache 中进行查找，如果有就返回query cache 的内容。
  > > >
  > > > query cache：需要 query_cache_size 和 query_cache_type；前者设置缓存大小，后者表示在那种场景下使用（0-OFF，1-ON，2-DEMAND）
  > > >
  > > > Qcache inserts表示多少次未命中然后插入；Qcache lowmem prunes 值大则说明缓存不够；Qcache hits 值非常大，则说明使用缓存较频繁；Qcache free blocks 表明缓存区的碎片，如果较多需要清理.	
  > >
  > > > InnoDB缓存：innodb_buffer_pool_size 设置缓存 InnoDB 索引及数据块的内存区域大小；table_cache 设置高速缓存的数量。
  > >
  > > - 平台级缓存
  > >
  > > > EhCache：
  > > >
  > > > > - 轻量快速：线程机制为大型高并发系统设计
  > > > > - 良性伸缩：数据可以伸缩到数 G 字节，节点可以到数百个
  > > > > - 简洁灵活：运行时缓存设置，存活时间、空闲时间、内存和缓存存放的最大数目可以在运行时修改
  > > > > - 标准支持：
  > > > > - 强扩展性：节点发现，冗余器和监听器可插件化
  > > > > - 数据持久：缓存的数据在机器重启后可以在磁盘上获取
  > > > > - 缓存监听：提供对缓存事件之后的处理机制
  > > > > - 分布式缓存：支持高性能的分布式缓存，兼具灵活性和扩展性
  > >
  > > - 应用级缓存
  > >
  > > > Redis：
  > >
  > > > 应用缓存技术：
  > > >
  > > > - 缓存命中：缓存中有这一对象，则使用缓存的数据
  > > > - 没有命中：cache miss ，缓存中还有空间的时候，没有命中的对象就会被放入缓存中
  > > > - 存储成本：没有命中缓存，需要从数据库中取出数据放入缓存，这个过程消耗的时间和空间叫做存储成本
  > > > - 缓存失效：存储在缓存中的数据要被更新时，则原数据就失效了
  > > > - 替代策略：当缓存已经满了，有新的数据来，需要从缓存中去除一条旧的数据放入新的数据，如何去除如何插入新的需要有替代策略
  > >
  > > > 替代策略：
  > > >
  > > > - Least-Recently-Used（LRU）：替换掉最近最少请求的对象
  > > > - Least-Frequently-Used（LFU）：替换掉访问次数最少的对象
  > > > - Least-Recently-Used 2（LRU2）：把最近访问两次的对象放入缓存，会把最近两次使用最少的缓存对象去除，需要跟踪对象两次，访问负载会增加
  > > > - Two  Queues（2Q）：把被访问的数据放到 KRU 的缓存中，如果这个对象在被访问一次，就把这个对象放到第二个、更大的 LRU 缓存中，使用多级缓存
  > > > - SIZE：替换占用空间最大的对象，这样会导致某些小对象可能一直存在与缓存中
  > > > - LRU-Threshold：不缓存超过某一大小的对象，其他与 LRU 相同
  > > > - Log(size)+LRU：替换最大的对象，size 相同时按照 LRU 处理
  > > > - Hyper-G：LFU 的改进，同时考虑上一次访问时间和大小
  > > > - Pitkow/Recker：替换最近最少使用的对象，除非所有对象都是今天使用的；如果都是今天则替换掉最大的对象
  > > > - Lowest-Latency-First：替换下载时间最少的文件
  > > > - Hybrid Hybrid：减少平均延迟，对缓存中的每个文档计算一个保留效用，保留效用最小的对象会被替换掉
  > > > - Lowest Relative Value（LRV）：计算保留效用，替换保留效用最低的对象
  > > > - Adaptive Replacement Cache（APC）：介于 LRU 和 LFU 中间，由两个 LRU 组成，第一个 LRU 包含最近只被使用过一次的，第二个包含最近被使用过两次的，以此得到新的和常用的对象；APC 可以自我调节，访问负载较小
  > > > - Most Recently Used（MRU）：MRU 与 LRU 是相对的，移除最近被最多使用的对象；（减少因为计算寻找最少最近的耗时）
  > > > - First in First out（FIFO）：通过队列跟踪缓存对象，最先进入的对象最先被踢走
  > > > - Random Cache：随意替换，效果比 FIFO 好，有些情况比 LRU 好
  > >
  > > > 云缓存服务：动态扩容、数据多备、自动容灾、成本较低