## SpringCloud 学习示例项目

---

### 微服务特点

- 按业务划分为一个独立运行的程序，即服务单元
- 服务之间通过 http 协议通信
- 自动化部署
- 可用不同的编程语言
- 可用不同的存储技术
- 服务集中化管理
- 微服务是一个分布式系统
### 微服务“微”
- 代码量
- 开发时间长短
- 业务大小
### CAP
- C（Consistency  一致性）：数据写入成功，之后读取读到的都是写入后的数据
- A（Availability  可用性）：服务的可用性
- P（Partition-tolerance  分区容错性）：单台或多台服务出现问题后，其他正常的服务仍可以正常提供服务
### 微服务具有的功能
- 服务的注册和发现
- 服务的负载均衡
- 服务的容错
- 服务的网关
- 服务配置的统一管理
- 链路追踪
- 实时日志
### Zookeeper和Eureka
||Zookeeper|Eureka|
|---|---|---|
|CAP|满足CP |满足AP|
|服务注册|当 master 节点 down 掉，剩余节点会重新选举 leader ，耗时30~120s，选取期间整个集群不可用，服务瘫痪|各个节点平等，当请求一个节点失败时会自动切换至另一个节点，但是不保证各个节点的强一致性 Eureka 还有一种自我保护机制，如果在 15 分钟内超过 85% 的节点都没有正常的心跳，那么 Eureka 就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况： 1.Eureka 不再从注册列表中移除因为长时间没收到心跳而应该过期的服务 2. Eureka 仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用) 3.当网络稳定时，当前实例新的注册信息会被同步到其它节点中|

### 负载均衡

- 将负载分摊到多个执行单元上，常见的两种方式

> - 独立进程单元，通过负载均衡策略，将请求发送到不同的执行单元上，例如 Nginx
> - 将负载均衡以代码逻辑的形式封装到服务消费者的客户端上，服务消费者维护了一份服务提供者的信息列表，通过负载均衡策略将请求分摊给多个服务提供者

### Feign

- 简化 Java Http 客户端远程调用
- Feign 采用的是http网络交互，可以采用`feign-httpclient`或者`okhttp`做网络请求框架，只需要在pom中添加相关依赖即可。
- Feign中负载均衡也是通过Ribbon来实现的。
- Feign请求过程


> - 通过 @EnableFeignClients 注解开启FeignClient功能；
> - 根据Feign的规则实现接口，并在接口上面加上 @FeignClient 注解；
> - 程序启动自动扫描 @FeignClient 注解的类，并注入到IoC容器；
> - 当接口的方法被调用时，通过JDK代理生成具体的 requestTemplate 对象，生成 http 请求的 request 对象；
> - 将 request 对象交给 Client 去处理，可以使用 HttpUrlConnection 、HttpClient 或 OkHttp；
> - 最后 Client 被封装到 LoadBalanceClient 类，这个类结合 Ribbon 实现负载均衡。

- Feign 可以直接配置 Hystrix 熔断器

### Hystrix

- 通过隔离服务的访问点组织联动故障，提供故障的解决方案，提高整个分布式系统的弹性

- #### 设计原则

> - 防止单个服务的故障耗尽整个那个服务的 Servlet 容器的线程资源
> - 快速失败机制，当某个服务出现故障，则调用该服务的线程快速失败而不是线程等待
> - 提供回退方案，请求发生故障时，按照提供的方案回退
> - 使用熔断机制，防止故障扩大影响到其他服务
> - 利用监控组件实时监控熔断器的状态

- #### Hystrix工作机制

> - 当某个API服务在一定时间内失败的次数大于设定阀值，触发熔断器打开，这时请求该API服务的接口会执行快速失败逻辑（即回退方案）。
> - 处于打开状态的熔断器，一段时间后，会处于半打开半关闭状态，将一定数量的请求执行正常逻辑，剩余的请求执行快速失败逻辑，如果执行正常逻辑的请求失败了，则熔断器继续打开，如果成功了，则熔断器关闭。

- #### 测试

> 执行请求中，断开两个服务提供方的其中一个，在短时间内的请求上仍然可以负载到 done 掉的服务上。在停止两个服务提供方后则会执行 fallback 配置的方法。

### Zuul

- #### 作用

> - Zuul、Ribbon 以及 Eureka 结合，可以实现智能路由和负载均衡，Zuul能够将请求流量按照某种策略分发到集群状态的多个服务实例；
> - 网关将所有的服务 API 接口统一聚合，并统一对外暴露。外界系统无需关注内部服务，也保护了内部的微服务单元避免敏感信息对外暴露；
> - 服务网关做用户身份认证和权限控制，防止非法请求操作API接口；
> - 网关实现监控功能，实时日志输出，对请求做记录；
> - 网关可以实现流量监控，在高流量的情况下，实现降级；
> - API 接口从内部服务分离处理，方便做测试

### 微服务链路追踪 Sleuth

- #### Dapper 中的专业术语：

> - **Span**：基本工作单元，发送一个远程调用服务就会产生一个 Span，Span 是一个64位的 ID， Span 包含了摘要、时间戳事件、Span 的 ID 以及进程的 ID 。
> - **Trace**：有一系列 Span 组成，呈树状结构。请求一个微服务系统的 API 接口，这个 API 接口需要调用多个微服务单元，每调用一个新的微服务单元都会产生一个 Span ，所有由这个请求产生的 Span 组成了这个 Trace。
> - **Annotation**：用于记录一个事件，一些核心注解用户定义一个请求的开始和结束：
>   - cs-Client Sent：客户端发送一个请求，描述 Span 的开始
>   - sr-Server Received：服务端获得请求并准备开始处理它，用 sr 减去 cs 时间戳，就是网络传输的时间
>   - ss-Server Sent：服务端发送响应，该注解表明请求处理的完成，用 ss 减去 sr 的时间戳就是服务端处理的时间长度
>   - cr-Client Received：客户端接受响应，此时 Span 结束，用 cr 减去 cs 的时间戳，就得到整个请求的耗时。

- ### Zipkin

> - 使用 RabbitMQ 传输链路数据，默认使用 Http 上传数据到 zipkin-server 的。
> - 可以使用 MySql、Elasticsearch 存储链路数据，如果在Elasticsearch中存储数据，可以利用 Kibana 展示数据。

### 微服务监控

- #### 

### Spring Boot Security

- #### 安全

> **认证**：认证主体，可以在应用程序中执行操作的用户、设备或其他系统
>
> **授权**：拥有什么权限，允许已认证的主体执行某一项操作

<div style="text-align:center;margin-top:50px;margin-bottom:50px;">
    <img src="https://note.youdao.com/yws/api/personal/file/C2C6FCFDC10942B6A3532E6F0928E455?method=download&shareKey=c554dacfc5193c29d4b35682aa1226d9" />
</div>
