## 慢查询及优化

查询的执行过程：客户端，到服务端后：会话连接、SQL分析、SQL 优化、生成执行计划、执行后返回结果。执行是整个生命周期最重要的阶段。

### 查询分析 EXPLAIN

| 属性          | 含义                                                         |
| ------------- | ------------------------------------------------------------ |
| id            | 查询中执行 select 子句或操作表的顺序，Id 相同执行顺序由上向下；id 越大优先级越高越先执行 |
| select_type   | select 子句查询类型，主要区别普通查询、联合查询、子查询等复杂查询 |
| table         | 数据库中表名称，行数据是关于哪张表，可能不一定是真实的表名称 |
| partitions    | 分区表命中的分区情况，非分区表该字段为空                     |
| type          | 访问类型，对表的访问方式                                     |
| possible_keys | 使用哪个索引能找到记录即该查询可以利用的索引。查询的列上若存在索引会被列出。如果没有则显示 NULL |
| key           | 实际查询过程中用到的索引，一定包含在 possible_keys 中，如果没有则显示 NULL |
| key_len       | 索引使用的字节数，如果是单列索引则是整个索引长度；如果是多列索引，则具体用到多少列索引就算多少 |
| ref           | 列与索引的比较，表的连接匹配条件，哪些列或常量被用于查找索引列上的值 |
| rows          | 估算结果集行数                                               |
| filtered      | 返回的结果行和需要扫描读到的行数的比值                       |
| Extra         | 解决查询的详细信息                                           |

#### select_type

- **simple**：简单的 select 查询，查询中不包含子查询或者 union
- **primary**：子查询中最外层查询，查询中包含任何复杂的子部分，最外层被标记
- **subquery**：在 select 或 where 列表中包含子查询，结果不依赖外部查询
- **dependent subquery**：子查询中第一个 select，依赖外部查询
- **uncacheable subquery**：一个子查询的结果不能被缓存，必须重新评估外链接第一行
- **derived**：在 from 列表中的子查询，MySQL 会递归执行这些子查询，然后把结果集放在临时表中
- **union**：如果第二个 select 出现在 union 之后，则被标记为 union；如果 union 包含在 from 子句的子查询中，外层 select 被标记为 derived
- **union result**：union 的结果，union 语句中第二个 select 后面的所有的 select
- **dependent union**：union 中第二个或后面的 select 语句

#### type

- **system**：表中仅有一行，const 连接类型的特殊情况
- **const**：通过索引一次就找到，const 用于比较主键索引和唯一索引，如果将主键放在了 where 条件中，MySQL 可以将其转换为常量
- **eq_ref**：唯一性索引扫描，对于每个索引键表中只会有一行记录与之匹配
- **ref**：非唯一性索引扫描，返回匹配某个单独值的所有行，本质上也是一种索引访问，它返回所有匹配某个单独值的行，可能会找多个符合条件的行，属于查找和扫描的混合体
- **ref_or_null**：与 ref 类似，增加了 null 值比较
- **range**：使用索引的范围扫描，见于使用 =, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, IN()或者like等运算符的查询中
- **index**：遍历索引树，不需要读取数据行，例如只通过覆盖索引就查找到目标数据
- **all**：全表扫描，然后在服务层根据条件过滤返回需要的记录
- **fulltext**：全文索引，优先级较高，如果全文索引和普通索引同时存在，MySQL 会优先使用全文索引
- **index_merge**：查询使用了两个以上的索引，最后取交集或者并集
- **unique_subquery**：用于 where 中的 in 形式子查询，子查询返回不重复唯一值
- **index_subquery**：用于 in 形式的子查询使用到了辅助索引或常数列表，子查询可能返回重复值，可以使用索引将子查询去重

#### ref

常数等值查询显示 const，连接表查询显示驱动表的关联字段，使用了表达式、函数、条件列发生内部隐式转换显示 func

#### Extra

- **distinct**：在 select 使用了 distinct 关键字
- **no table used**：不带 from 子句的查询或者 from dual
- 使用 not in() 形式子查询或者 not exist 连接查询，这种叫做反连接。一般连接查询是先查内表再查外表，这种是先查外表再查内表
- **using filesort**：排序时无法使用到索引，常见于 ORDER BY 和  GROUP BY 语句中
- **using index**：查询时不需要回表，直接通过索引就可以查询
- **using where**：存储引擎返回的记录不满足查询条件，需要在服务层通过条件过滤
- **using join buffer**：使用了连接缓存，减少内表的循环数量以及顺序的扫描查询
- **using sort_union**：表示使用 and 的各个索引的条件时，该信息表示是从处理结果获取交集
- **using_union**：表示使用 or 连接各个使用索引的条件时，该信息表示从处理结果获取并集
- **using sort_union**：表示使用 and 连接查询信息量大时，先查询主键，然后进行排序合并后，才能读取记录并返回。
- **using sort_intersection**：表示使用 or 连接查询信息量大时，先查询主键，然后进行排序合并后，才能读取记录并返回。
- **firstmatch(td_name)**：常见于 where 子句还有 in() 类查询，内表数据量大可能出现
- **loosescan(m...n)**：在 in() 类型的子查询中，子查询返回的可能有重复记录

### 慢查询

查询性能最基本的原因是访问不必要或者太多的数据。主要通过两个步骤来分析：应用是否检索了大量超过实际需要的数据，包括太多的行数据或者列数据；服务层是否在分析大量超过实际需要的行。

#### 不需要的数据

- **查询不需要的记录：**利用 `limit` 优化自己需要的记录行
- **多表关联时返回全部列：**注意多表关联的情况，一般可能只需要关联表的某个字段而不是全部字段
- **取出全部列：**使用了 `SELECT *`，可能情况比较少。使用 * 会让优化器无法利用覆盖索引完成优化，取出实际需要的列即可
- **重复查询相同的数据：**执行相同的查询、返回相同的数据。考虑合理利用缓存

#### 扫描额外的记录

主要是在查询执行过程中是否扫描了过多的行数据，考虑是否可以优化

- **响应时间：**响应时间主要包括两部分：服务时间和排队时间，服务时间是指数据库处理这个查询花费的具体时间，排队时间是服务器要等待某些资源没有没有执行查询的时间
- **扫描的行数和返回的行数：**最好的情况就是扫描的行就是需要的返回的行，避免无用的行扫描
- **扫描的行数和访问类型：**EXPLAIN 的 type 列反映了访问类型(全表扫描、索引扫描、范围扫描、唯一索引扫描、常数引用)。所以可以让 MySQL 以高效、扫描行数少的方式找到需要的记录

MySQL 应用 WHERE 条件的场景：

- 在索引中使用 WHERE 条件在存储引擎层过滤不匹配的记录
- 使用索引覆盖扫描来返回记录，在 EXTRA (using index) 。直接从索引中返回结果这是在服务器层完成不需要回表查询
- 从数据表中返回结果，过滤不满足条件的记录，在 EXTRA (using where) 。在服务层完成，先从数据表读出记录然后过滤

如果发现需要扫描大量的行但是只返回少量的数据，可以从下面几个方面考虑优化：

- 是否可以优化为从覆盖索引扫描，把需要的列放在覆盖索引中，查询索引时直接返回
- 优化数据库、表结构
- 优化查询 SQL

